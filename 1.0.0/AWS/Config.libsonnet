local d = import 'github.com/jsonnet-libs/docsonnet/doc-util/main.libsonnet';
{
  AggregationAuthorization: {
    '#': d.pkg(
      name='AggregationAuthorization',
      url='github.com/the-fittest/cloudformation-libsonnet/1.0.0/AWS/Config.libsonnet',
      help='Resource Type definition for AWS::Config::AggregationAuthorization',
      filename=std.thisFile,
    ),
    '#new': d.fn(
      help=|||
        `new` creates a AWS::Config::AggregationAuthorization Resource
        * AuthorizedAccountId The 12-digit account ID of the account authorized to aggregate data.
        * AuthorizedAwsRegion The region authorized to collect aggregated data.
      |||,
      args=[
        d.arg('AuthorizedAccountId', 'd.T.string'),
        d.arg('AuthorizedAwsRegion', 'd.T.string'),
      ]
    ),
    new(
      AuthorizedAccountId,
      AuthorizedAwsRegion,
    ): {
      local base = self,
      Properties: {
        assert std.isString(AuthorizedAccountId) : 'AuthorizedAccountId must be a string',
        AuthorizedAccountId: AuthorizedAccountId,
        assert std.isString(AuthorizedAwsRegion) : 'AuthorizedAwsRegion must be a string',
        AuthorizedAwsRegion: AuthorizedAwsRegion,
      },
      DependsOn:: [],
      Type: 'AWS::Config::AggregationAuthorization',
    },
    dependsOn(DependsOn): {
      DependsOn::: [DependsOn],
    },
    '#withAggregationAuthorizationArn': d.fn('`withAggregationAuthorizationArn` AggregationAuthorizationArn ', [d.arg('AggregationAuthorizationArn', d.T.string)]),
    withAggregationAuthorizationArn(AggregationAuthorizationArn): {
      assert std.isString(AggregationAuthorizationArn) : 'AggregationAuthorizationArn must be a string',
      Properties+::: { AggregationAuthorizationArn: AggregationAuthorizationArn },
    },
    '#withTags': d.fn('`withTags` Tags ', [d.arg('Tags', d.T.array)]),
    withTags(Tags): {
      assert std.isArray(Tags) : 'Tags must be a array',
      Properties+::: { Tags: Tags },
    },
  },
  ConfigRule: {
    '#': d.pkg(
      name='ConfigRule',
      url='github.com/the-fittest/cloudformation-libsonnet/1.0.0/AWS/Config.libsonnet',
      help='You must first create and start the CC configuration recorder in order to create CC managed rules with CFNlong. For more information, see [Managing the Configuration Recorder](https://docs.aws.amazon.com/config/latest/developerguide/stop-start-recorder.html). Adds or updates an CC rule to evaluate if your AWS resources comply with your desired configurations. For information on how many CC rules you can have per account, see [Service Limits](https://docs.aws.amazon.com/config/latest/developerguide/configlimits.html) in the *Developer Guide*. There are two types of rules: *Managed Rules* and *Custom Rules*. You can use the ConfigRule resource to create both CC Managed Rules and CC Custom Rules. CC Managed Rules are predefined, customizable rules created by CC. For a list of managed rules, see [List of Managed Rules](https://docs.aws.amazon.com/config/latest/developerguide/managed-rules-by-aws-config.html). If you are adding an CC managed rule, you must specify the rules identifier for the SourceIdentifier key. CC Custom Rules are rules that you create from scratch. There are two ways to create CC custom rules: with Lambda functions ([Developer Guide](https://docs.aws.amazon.com/config/latest/developerguide/gettingstarted-concepts.html#gettingstarted-concepts-function)) and with CFNGUARDshort ([Guard GitHub Repository](https://docs.aws.amazon.com/https://github.com/aws-cloudformation/cloudformation-guard)), a policy-as-code language. CC custom rules created with LAMlong are called *Custom Lambda Rules* and CC custom rules created with CFNGUARDshort are called *Custom Policy Rules*. If you are adding a new CC Custom LAM rule, you first need to create an LAMlong function that the rule invokes to evaluate your resources. When you use the ConfigRule resource to add a Custom LAM rule to CC, you must specify the Amazon Resource Name (ARN) that LAMlong assigns to the function. You specify the ARN in the SourceIdentifier key. This key is part of the Source object, which is part of the ConfigRule object.  For any new CC rule that you add, specify the ConfigRuleName in the ConfigRule object. Do not specify the ConfigRuleArn or the ConfigRuleId. These values are generated by CC for new rules. If you are updating a rule that you added previously, you can specify the rule by ConfigRuleName, ConfigRuleId, or ConfigRuleArn in the ConfigRule data type that you use in this request. For more information about developing and using CC rules, see [Evaluating Resources with Rules](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config.html) in the *Developer Guide*.',
      filename=std.thisFile,
    ),
    '#new': d.fn(
      help=|||
        `new` creates a AWS::Config::ConfigRule Resource
        * Source Provides the rule owner ( for managed rules, CUSTOM_POLICY for Custom Policy rules, and CUSTOM_LAMBDA for Custom Lambda rules), the rule identifier, and the notifications that cause the function to evaluate your AWS resources.
      |||,
      args=[
        d.arg('Source', 'd.T.object'),
      ]
    ),
    new(
      Source,
    ): {
      local base = self,
      Properties: {
        assert std.isObject(Source) : 'Source must be a object',
        Source: Source,
      },
      DependsOn:: [],
      Type: 'AWS::Config::ConfigRule',
    },
    dependsOn(DependsOn): {
      DependsOn::: [DependsOn],
    },
    '#withConfigRuleId': d.fn('`withConfigRuleId` ConfigRuleId ', [d.arg('ConfigRuleId', d.T.string)]),
    withConfigRuleId(ConfigRuleId): {
      assert std.isString(ConfigRuleId) : 'ConfigRuleId must be a string',
      Properties+::: { ConfigRuleId: ConfigRuleId },
    },
    '#withDescription': d.fn('`withDescription` Description ', [d.arg('Description', d.T.string)]),
    withDescription(Description): {
      assert std.isString(Description) : 'Description must be a string',
      Properties+::: { Description: Description },
    },
    '#withScope': d.fn('`withScope` Scope ', [d.arg('Scope', d.T.object)]),
    withScope(Scope): {
      assert std.isObject(Scope) : 'Scope must be a object',
      Properties+::: { Scope: Scope },
    },
    '#withConfigRuleName': d.fn('`withConfigRuleName` ConfigRuleName ', [d.arg('ConfigRuleName', d.T.string)]),
    withConfigRuleName(ConfigRuleName): {
      assert std.isString(ConfigRuleName) : 'ConfigRuleName must be a string',
      Properties+::: { ConfigRuleName: ConfigRuleName },
    },
    '#withArn': d.fn('`withArn` Arn ', [d.arg('Arn', d.T.string)]),
    withArn(Arn): {
      assert std.isString(Arn) : 'Arn must be a string',
      Properties+::: { Arn: Arn },
    },
    '#withCompliance': d.fn('`withCompliance` Compliance ', [d.arg('Compliance', d.T.object)]),
    withCompliance(Compliance): {
      assert std.isObject(Compliance) : 'Compliance must be a object',
      Properties+::: { Compliance: Compliance },
    },
    '#withMaximumExecutionFrequency': d.fn('`withMaximumExecutionFrequency` MaximumExecutionFrequency ', [d.arg('MaximumExecutionFrequency', d.T.string)]),
    withMaximumExecutionFrequency(MaximumExecutionFrequency): {
      assert std.isString(MaximumExecutionFrequency) : 'MaximumExecutionFrequency must be a string',
      Properties+::: { MaximumExecutionFrequency: MaximumExecutionFrequency },
    },
    '#withInputParameters': d.fn('`withInputParameters` InputParameters ', [d.arg('InputParameters')]),
    withInputParameters(InputParameters): {
      // Type: string,object
      Properties+::: { InputParameters: InputParameters },
    },
    '#withEvaluationModes': d.fn('`withEvaluationModes` EvaluationModes ', [d.arg('EvaluationModes', d.T.array)]),
    withEvaluationModes(EvaluationModes): {
      assert std.isArray(EvaluationModes) : 'EvaluationModes must be a array',
      Properties+::: { EvaluationModes: EvaluationModes },
    },
  },
  ConfigurationAggregator: {
    '#': d.pkg(
      name='ConfigurationAggregator',
      url='github.com/the-fittest/cloudformation-libsonnet/1.0.0/AWS/Config.libsonnet',
      help='Resource Type definition for AWS::Config::ConfigurationAggregator',
      filename=std.thisFile,
    ),
    '#new': d.fn(
      help=|||
        `new` creates a AWS::Config::ConfigurationAggregator Resource
      |||,
    ),
    new(): {
      local base = self,
      Properties:: {},
      DependsOn:: [],
      Type: 'AWS::Config::ConfigurationAggregator',
    },
    dependsOn(DependsOn): {
      DependsOn::: [DependsOn],
    },
    '#withAccountAggregationSources': d.fn('`withAccountAggregationSources` AccountAggregationSources ', [d.arg('AccountAggregationSources', d.T.array)]),
    withAccountAggregationSources(AccountAggregationSources): {
      assert std.isArray(AccountAggregationSources) : 'AccountAggregationSources must be a array',
      Properties+::: { AccountAggregationSources: AccountAggregationSources },
    },
    '#withConfigurationAggregatorName': d.fn('`withConfigurationAggregatorName` ConfigurationAggregatorName ', [d.arg('ConfigurationAggregatorName', d.T.string)]),
    withConfigurationAggregatorName(ConfigurationAggregatorName): {
      assert std.isString(ConfigurationAggregatorName) : 'ConfigurationAggregatorName must be a string',
      Properties+::: { ConfigurationAggregatorName: ConfigurationAggregatorName },
    },
    '#withConfigurationAggregatorArn': d.fn('`withConfigurationAggregatorArn` ConfigurationAggregatorArn ', [d.arg('ConfigurationAggregatorArn', d.T.string)]),
    withConfigurationAggregatorArn(ConfigurationAggregatorArn): {
      assert std.isString(ConfigurationAggregatorArn) : 'ConfigurationAggregatorArn must be a string',
      Properties+::: { ConfigurationAggregatorArn: ConfigurationAggregatorArn },
    },
    '#withOrganizationAggregationSource': d.fn('`withOrganizationAggregationSource` OrganizationAggregationSource ', [d.arg('OrganizationAggregationSource', d.T.object)]),
    withOrganizationAggregationSource(OrganizationAggregationSource): {
      assert std.isObject(OrganizationAggregationSource) : 'OrganizationAggregationSource must be a object',
      Properties+::: { OrganizationAggregationSource: OrganizationAggregationSource },
    },
    '#withTags': d.fn('`withTags` Tags ', [d.arg('Tags', d.T.array)]),
    withTags(Tags): {
      assert std.isArray(Tags) : 'Tags must be a array',
      Properties+::: { Tags: Tags },
    },
  },
  ConfigurationRecorder: {
    '#': d.pkg(
      name='ConfigurationRecorder',
      url='github.com/the-fittest/cloudformation-libsonnet/1.0.0/AWS/Config.libsonnet',
      help='Resource Type definition for AWS::Config::ConfigurationRecorder',
      filename=std.thisFile,
    ),
    '#new': d.fn(
      help=|||
        `new` creates a AWS::Config::ConfigurationRecorder Resource
        * RoleARN 
      |||,
      args=[
        d.arg('RoleARN', 'd.T.string'),
      ]
    ),
    new(
      RoleARN,
    ): {
      local base = self,
      Properties: {
        assert std.isString(RoleARN) : 'RoleARN must be a string',
        RoleARN: RoleARN,
      },
      DependsOn:: [],
      Type: 'AWS::Config::ConfigurationRecorder',
    },
    dependsOn(DependsOn): {
      DependsOn::: [DependsOn],
    },
    '#withId': d.fn('`withId` Id ', [d.arg('Id', d.T.string)]),
    withId(Id): {
      assert std.isString(Id) : 'Id must be a string',
      Properties+::: { Id: Id },
    },
    '#withRecordingGroup': d.fn('`withRecordingGroup` RecordingGroup ', [d.arg('RecordingGroup', d.T.object)]),
    withRecordingGroup(RecordingGroup): {
      assert std.isObject(RecordingGroup) : 'RecordingGroup must be a object',
      Properties+::: { RecordingGroup: RecordingGroup },
    },
    '#withRecordingMode': d.fn('`withRecordingMode` RecordingMode ', [d.arg('RecordingMode', d.T.object)]),
    withRecordingMode(RecordingMode): {
      assert std.isObject(RecordingMode) : 'RecordingMode must be a object',
      Properties+::: { RecordingMode: RecordingMode },
    },
    '#withName': d.fn('`withName` Name ', [d.arg('Name', d.T.string)]),
    withName(Name): {
      assert std.isString(Name) : 'Name must be a string',
      Properties+::: { Name: Name },
    },
  },
  ConformancePack: {
    '#': d.pkg(
      name='ConformancePack',
      url='github.com/the-fittest/cloudformation-libsonnet/1.0.0/AWS/Config.libsonnet',
      help='A conformance pack is a collection of AWS Config rules and remediation actions that can be easily deployed as a single entity in an account and a region or across an entire AWS Organization.',
      filename=std.thisFile,
    ),
    '#new': d.fn(
      help=|||
        `new` creates a AWS::Config::ConformancePack Resource
        * ConformancePackName Name of the conformance pack which will be assigned as the unique identifier.
      |||,
      args=[
        d.arg('ConformancePackName', 'd.T.string'),
      ]
    ),
    new(
      ConformancePackName,
    ): {
      local base = self,
      Properties: {
        assert std.isString(ConformancePackName) : 'ConformancePackName must be a string',
        ConformancePackName: ConformancePackName,
      },
      DependsOn:: [],
      Type: 'AWS::Config::ConformancePack',
    },
    dependsOn(DependsOn): {
      DependsOn::: [DependsOn],
    },
    '#withDeliveryS3Bucket': d.fn('`withDeliveryS3Bucket` DeliveryS3Bucket ', [d.arg('DeliveryS3Bucket', d.T.string)]),
    withDeliveryS3Bucket(DeliveryS3Bucket): {
      assert std.isString(DeliveryS3Bucket) : 'DeliveryS3Bucket must be a string',
      Properties+::: { DeliveryS3Bucket: DeliveryS3Bucket },
    },
    '#withDeliveryS3KeyPrefix': d.fn('`withDeliveryS3KeyPrefix` DeliveryS3KeyPrefix ', [d.arg('DeliveryS3KeyPrefix', d.T.string)]),
    withDeliveryS3KeyPrefix(DeliveryS3KeyPrefix): {
      assert std.isString(DeliveryS3KeyPrefix) : 'DeliveryS3KeyPrefix must be a string',
      Properties+::: { DeliveryS3KeyPrefix: DeliveryS3KeyPrefix },
    },
    '#withTemplateBody': d.fn('`withTemplateBody` TemplateBody ', [d.arg('TemplateBody', d.T.string)]),
    withTemplateBody(TemplateBody): {
      assert std.isString(TemplateBody) : 'TemplateBody must be a string',
      Properties+::: { TemplateBody: TemplateBody },
    },
    '#withTemplateS3Uri': d.fn('`withTemplateS3Uri` TemplateS3Uri ', [d.arg('TemplateS3Uri', d.T.string)]),
    withTemplateS3Uri(TemplateS3Uri): {
      assert std.isString(TemplateS3Uri) : 'TemplateS3Uri must be a string',
      Properties+::: { TemplateS3Uri: TemplateS3Uri },
    },
    '#withTemplateSSMDocumentDetails': d.fn('`withTemplateSSMDocumentDetails` TemplateSSMDocumentDetails ', [d.arg('TemplateSSMDocumentDetails', d.T.object)]),
    withTemplateSSMDocumentDetails(TemplateSSMDocumentDetails): {
      assert std.isObject(TemplateSSMDocumentDetails) : 'TemplateSSMDocumentDetails must be a object',
      Properties+::: { TemplateSSMDocumentDetails: TemplateSSMDocumentDetails },
    },
    '#withConformancePackInputParameters': d.fn('`withConformancePackInputParameters` ConformancePackInputParameters ', [d.arg('ConformancePackInputParameters', d.T.array)]),
    withConformancePackInputParameters(ConformancePackInputParameters): {
      assert std.isArray(ConformancePackInputParameters) : 'ConformancePackInputParameters must be a array',
      Properties+::: { ConformancePackInputParameters: ConformancePackInputParameters },
    },
  },
  DeliveryChannel: {
    '#': d.pkg(
      name='DeliveryChannel',
      url='github.com/the-fittest/cloudformation-libsonnet/1.0.0/AWS/Config.libsonnet',
      help='Resource Type definition for AWS::Config::DeliveryChannel',
      filename=std.thisFile,
    ),
    '#new': d.fn(
      help=|||
        `new` creates a AWS::Config::DeliveryChannel Resource
        * S3BucketName 
      |||,
      args=[
        d.arg('S3BucketName', 'd.T.string'),
      ]
    ),
    new(
      S3BucketName,
    ): {
      local base = self,
      Properties: {
        assert std.isString(S3BucketName) : 'S3BucketName must be a string',
        S3BucketName: S3BucketName,
      },
      DependsOn:: [],
      Type: 'AWS::Config::DeliveryChannel',
    },
    dependsOn(DependsOn): {
      DependsOn::: [DependsOn],
    },
    '#withS3KeyPrefix': d.fn('`withS3KeyPrefix` S3KeyPrefix ', [d.arg('S3KeyPrefix', d.T.string)]),
    withS3KeyPrefix(S3KeyPrefix): {
      assert std.isString(S3KeyPrefix) : 'S3KeyPrefix must be a string',
      Properties+::: { S3KeyPrefix: S3KeyPrefix },
    },
    '#withConfigSnapshotDeliveryProperties': d.fn('`withConfigSnapshotDeliveryProperties` ConfigSnapshotDeliveryProperties ', [d.arg('ConfigSnapshotDeliveryProperties', d.T.object)]),
    withConfigSnapshotDeliveryProperties(ConfigSnapshotDeliveryProperties): {
      assert std.isObject(ConfigSnapshotDeliveryProperties) : 'ConfigSnapshotDeliveryProperties must be a object',
      Properties+::: { ConfigSnapshotDeliveryProperties: ConfigSnapshotDeliveryProperties },
    },
    '#withSnsTopicARN': d.fn('`withSnsTopicARN` SnsTopicARN ', [d.arg('SnsTopicARN', d.T.string)]),
    withSnsTopicARN(SnsTopicARN): {
      assert std.isString(SnsTopicARN) : 'SnsTopicARN must be a string',
      Properties+::: { SnsTopicARN: SnsTopicARN },
    },
    '#withId': d.fn('`withId` Id ', [d.arg('Id', d.T.string)]),
    withId(Id): {
      assert std.isString(Id) : 'Id must be a string',
      Properties+::: { Id: Id },
    },
    '#withS3KmsKeyArn': d.fn('`withS3KmsKeyArn` S3KmsKeyArn ', [d.arg('S3KmsKeyArn', d.T.string)]),
    withS3KmsKeyArn(S3KmsKeyArn): {
      assert std.isString(S3KmsKeyArn) : 'S3KmsKeyArn must be a string',
      Properties+::: { S3KmsKeyArn: S3KmsKeyArn },
    },
    '#withName': d.fn('`withName` Name ', [d.arg('Name', d.T.string)]),
    withName(Name): {
      assert std.isString(Name) : 'Name must be a string',
      Properties+::: { Name: Name },
    },
  },
  OrganizationConfigRule: {
    '#': d.pkg(
      name='OrganizationConfigRule',
      url='github.com/the-fittest/cloudformation-libsonnet/1.0.0/AWS/Config.libsonnet',
      help='Resource Type definition for AWS::Config::OrganizationConfigRule',
      filename=std.thisFile,
    ),
    '#new': d.fn(
      help=|||
        `new` creates a AWS::Config::OrganizationConfigRule Resource
        * OrganizationConfigRuleName 
      |||,
      args=[
        d.arg('OrganizationConfigRuleName', 'd.T.string'),
      ]
    ),
    new(
      OrganizationConfigRuleName,
    ): {
      local base = self,
      Properties: {
        assert std.isString(OrganizationConfigRuleName) : 'OrganizationConfigRuleName must be a string',
        OrganizationConfigRuleName: OrganizationConfigRuleName,
      },
      DependsOn:: [],
      Type: 'AWS::Config::OrganizationConfigRule',
    },
    dependsOn(DependsOn): {
      DependsOn::: [DependsOn],
    },
    '#withOrganizationCustomRuleMetadata': d.fn('`withOrganizationCustomRuleMetadata` OrganizationCustomRuleMetadata ', [d.arg('OrganizationCustomRuleMetadata', d.T.object)]),
    withOrganizationCustomRuleMetadata(OrganizationCustomRuleMetadata): {
      assert std.isObject(OrganizationCustomRuleMetadata) : 'OrganizationCustomRuleMetadata must be a object',
      Properties+::: { OrganizationCustomRuleMetadata: OrganizationCustomRuleMetadata },
    },
    '#withOrganizationManagedRuleMetadata': d.fn('`withOrganizationManagedRuleMetadata` OrganizationManagedRuleMetadata ', [d.arg('OrganizationManagedRuleMetadata', d.T.object)]),
    withOrganizationManagedRuleMetadata(OrganizationManagedRuleMetadata): {
      assert std.isObject(OrganizationManagedRuleMetadata) : 'OrganizationManagedRuleMetadata must be a object',
      Properties+::: { OrganizationManagedRuleMetadata: OrganizationManagedRuleMetadata },
    },
    '#withExcludedAccounts': d.fn('`withExcludedAccounts` ExcludedAccounts ', [d.arg('ExcludedAccounts', d.T.array)]),
    withExcludedAccounts(ExcludedAccounts): {
      assert std.isArray(ExcludedAccounts) : 'ExcludedAccounts must be a array',
      Properties+::: { ExcludedAccounts: ExcludedAccounts },
    },
    '#withId': d.fn('`withId` Id ', [d.arg('Id', d.T.string)]),
    withId(Id): {
      assert std.isString(Id) : 'Id must be a string',
      Properties+::: { Id: Id },
    },
    '#withOrganizationCustomPolicyRuleMetadata': d.fn('`withOrganizationCustomPolicyRuleMetadata` OrganizationCustomPolicyRuleMetadata ', [d.arg('OrganizationCustomPolicyRuleMetadata', d.T.object)]),
    withOrganizationCustomPolicyRuleMetadata(OrganizationCustomPolicyRuleMetadata): {
      assert std.isObject(OrganizationCustomPolicyRuleMetadata) : 'OrganizationCustomPolicyRuleMetadata must be a object',
      Properties+::: { OrganizationCustomPolicyRuleMetadata: OrganizationCustomPolicyRuleMetadata },
    },
  },
  OrganizationConformancePack: {
    '#': d.pkg(
      name='OrganizationConformancePack',
      url='github.com/the-fittest/cloudformation-libsonnet/1.0.0/AWS/Config.libsonnet',
      help='Resource schema for AWS::Config::OrganizationConformancePack.',
      filename=std.thisFile,
    ),
    '#new': d.fn(
      help=|||
        `new` creates a AWS::Config::OrganizationConformancePack Resource
        * OrganizationConformancePackName The name of the organization conformance pack.
      |||,
      args=[
        d.arg('OrganizationConformancePackName', 'd.T.string'),
      ]
    ),
    new(
      OrganizationConformancePackName,
    ): {
      local base = self,
      Properties: {
        assert std.isString(OrganizationConformancePackName) : 'OrganizationConformancePackName must be a string',
        OrganizationConformancePackName: OrganizationConformancePackName,
      },
      DependsOn:: [],
      Type: 'AWS::Config::OrganizationConformancePack',
    },
    dependsOn(DependsOn): {
      DependsOn::: [DependsOn],
    },
    '#withTemplateS3Uri': d.fn('`withTemplateS3Uri` TemplateS3Uri ', [d.arg('TemplateS3Uri', d.T.string)]),
    withTemplateS3Uri(TemplateS3Uri): {
      assert std.isString(TemplateS3Uri) : 'TemplateS3Uri must be a string',
      Properties+::: { TemplateS3Uri: TemplateS3Uri },
    },
    '#withTemplateBody': d.fn('`withTemplateBody` TemplateBody ', [d.arg('TemplateBody', d.T.string)]),
    withTemplateBody(TemplateBody): {
      assert std.isString(TemplateBody) : 'TemplateBody must be a string',
      Properties+::: { TemplateBody: TemplateBody },
    },
    '#withDeliveryS3Bucket': d.fn('`withDeliveryS3Bucket` DeliveryS3Bucket ', [d.arg('DeliveryS3Bucket', d.T.string)]),
    withDeliveryS3Bucket(DeliveryS3Bucket): {
      assert std.isString(DeliveryS3Bucket) : 'DeliveryS3Bucket must be a string',
      Properties+::: { DeliveryS3Bucket: DeliveryS3Bucket },
    },
    '#withDeliveryS3KeyPrefix': d.fn('`withDeliveryS3KeyPrefix` DeliveryS3KeyPrefix ', [d.arg('DeliveryS3KeyPrefix', d.T.string)]),
    withDeliveryS3KeyPrefix(DeliveryS3KeyPrefix): {
      assert std.isString(DeliveryS3KeyPrefix) : 'DeliveryS3KeyPrefix must be a string',
      Properties+::: { DeliveryS3KeyPrefix: DeliveryS3KeyPrefix },
    },
    '#withConformancePackInputParameters': d.fn('`withConformancePackInputParameters` ConformancePackInputParameters ', [d.arg('ConformancePackInputParameters', d.T.array)]),
    withConformancePackInputParameters(ConformancePackInputParameters): {
      assert std.isArray(ConformancePackInputParameters) : 'ConformancePackInputParameters must be a array',
      Properties+::: { ConformancePackInputParameters: ConformancePackInputParameters },
    },
    '#withExcludedAccounts': d.fn('`withExcludedAccounts` ExcludedAccounts ', [d.arg('ExcludedAccounts', d.T.array)]),
    withExcludedAccounts(ExcludedAccounts): {
      assert std.isArray(ExcludedAccounts) : 'ExcludedAccounts must be a array',
      Properties+::: { ExcludedAccounts: ExcludedAccounts },
    },
  },
  RemediationConfiguration: {
    '#': d.pkg(
      name='RemediationConfiguration',
      url='github.com/the-fittest/cloudformation-libsonnet/1.0.0/AWS/Config.libsonnet',
      help='Resource Type definition for AWS::Config::RemediationConfiguration',
      filename=std.thisFile,
    ),
    '#new': d.fn(
      help=|||
        `new` creates a AWS::Config::RemediationConfiguration Resource
        * TargetType 
        * ConfigRuleName 
        * TargetId 
      |||,
      args=[
        d.arg('TargetType', 'd.T.string'),
        d.arg('ConfigRuleName', 'd.T.string'),
        d.arg('TargetId', 'd.T.string'),
      ]
    ),
    new(
      TargetType,
      ConfigRuleName,
      TargetId,
    ): {
      local base = self,
      Properties: {
        assert std.isString(TargetType) : 'TargetType must be a string',
        TargetType: TargetType,
        assert std.isString(ConfigRuleName) : 'ConfigRuleName must be a string',
        ConfigRuleName: ConfigRuleName,
        assert std.isString(TargetId) : 'TargetId must be a string',
        TargetId: TargetId,
      },
      DependsOn:: [],
      Type: 'AWS::Config::RemediationConfiguration',
    },
    dependsOn(DependsOn): {
      DependsOn::: [DependsOn],
    },
    '#withTargetVersion': d.fn('`withTargetVersion` TargetVersion ', [d.arg('TargetVersion', d.T.string)]),
    withTargetVersion(TargetVersion): {
      assert std.isString(TargetVersion) : 'TargetVersion must be a string',
      Properties+::: { TargetVersion: TargetVersion },
    },
    '#withExecutionControls': d.fn('`withExecutionControls` ExecutionControls ', [d.arg('ExecutionControls', d.T.object)]),
    withExecutionControls(ExecutionControls): {
      assert std.isObject(ExecutionControls) : 'ExecutionControls must be a object',
      Properties+::: { ExecutionControls: ExecutionControls },
    },
    '#withParameters': d.fn('`withParameters` Parameters ', [d.arg('Parameters', d.T.object)]),
    withParameters(Parameters): {
      assert std.isObject(Parameters) : 'Parameters must be a object',
      Properties+::: { Parameters: Parameters },
    },
    '#withResourceType': d.fn('`withResourceType` ResourceType ', [d.arg('ResourceType', d.T.string)]),
    withResourceType(ResourceType): {
      assert std.isString(ResourceType) : 'ResourceType must be a string',
      Properties+::: { ResourceType: ResourceType },
    },
    '#withRetryAttemptSeconds': d.fn('`withRetryAttemptSeconds` RetryAttemptSeconds ', [d.arg('RetryAttemptSeconds', d.T.integer)]),
    withRetryAttemptSeconds(RetryAttemptSeconds): {
      assert std.isNumber(RetryAttemptSeconds) : 'RetryAttemptSeconds must be a integer',
      Properties+::: { RetryAttemptSeconds: RetryAttemptSeconds },
    },
    '#withMaximumAutomaticAttempts': d.fn('`withMaximumAutomaticAttempts` MaximumAutomaticAttempts ', [d.arg('MaximumAutomaticAttempts', d.T.integer)]),
    withMaximumAutomaticAttempts(MaximumAutomaticAttempts): {
      assert std.isNumber(MaximumAutomaticAttempts) : 'MaximumAutomaticAttempts must be a integer',
      Properties+::: { MaximumAutomaticAttempts: MaximumAutomaticAttempts },
    },
    '#withId': d.fn('`withId` Id ', [d.arg('Id', d.T.string)]),
    withId(Id): {
      assert std.isString(Id) : 'Id must be a string',
      Properties+::: { Id: Id },
    },
    '#withAutomatic': d.fn('`withAutomatic` Automatic ', [d.arg('Automatic', d.T.boolean)]),
    withAutomatic(Automatic): {
      assert std.isBoolean(Automatic) : 'Automatic must be a boolean',
      Properties+::: { Automatic: Automatic },
    },
  },
  StoredQuery: {
    '#': d.pkg(
      name='StoredQuery',
      url='github.com/the-fittest/cloudformation-libsonnet/1.0.0/AWS/Config.libsonnet',
      help='Resource Type definition for AWS::Config::StoredQuery',
      filename=std.thisFile,
    ),
    '#new': d.fn(
      help=|||
        `new` creates a AWS::Config::StoredQuery Resource
        * QueryName 
        * QueryExpression 
      |||,
      args=[
        d.arg('QueryName', 'd.T.string'),
        d.arg('QueryExpression', 'd.T.string'),
      ]
    ),
    new(
      QueryName,
      QueryExpression,
    ): {
      local base = self,
      Properties: {
        assert std.isString(QueryName) : 'QueryName must be a string',
        QueryName: QueryName,
        assert std.isString(QueryExpression) : 'QueryExpression must be a string',
        QueryExpression: QueryExpression,
      },
      DependsOn:: [],
      Type: 'AWS::Config::StoredQuery',
    },
    dependsOn(DependsOn): {
      DependsOn::: [DependsOn],
    },
    '#withQueryArn': d.fn('`withQueryArn` QueryArn ', [d.arg('QueryArn', d.T.string)]),
    withQueryArn(QueryArn): {
      assert std.isString(QueryArn) : 'QueryArn must be a string',
      Properties+::: { QueryArn: QueryArn },
    },
    '#withQueryId': d.fn('`withQueryId` QueryId ', [d.arg('QueryId', d.T.string)]),
    withQueryId(QueryId): {
      assert std.isString(QueryId) : 'QueryId must be a string',
      Properties+::: { QueryId: QueryId },
    },
    '#withQueryDescription': d.fn('`withQueryDescription` QueryDescription ', [d.arg('QueryDescription', d.T.string)]),
    withQueryDescription(QueryDescription): {
      assert std.isString(QueryDescription) : 'QueryDescription must be a string',
      Properties+::: { QueryDescription: QueryDescription },
    },
    '#withTags': d.fn('`withTags` Tags ', [d.arg('Tags', d.T.array)]),
    withTags(Tags): {
      assert std.isArray(Tags) : 'Tags must be a array',
      Properties+::: { Tags: Tags },
    },
  },
}

<%
    const buildEnumAssert = (key, enums) => {
        if (_.isArray(enums)) {
            let check = '', message = '';
            enums.forEach((enumValue, index) => {
                // string must be enclosed in parentheses
                let value = `'${enumValue}'`;
                // number does not need parentheses
                if (_.isNumber(enumValue)) value = `${enumValue}`;

                check += `${key} == ${value}`;
                message += value;

                if (index < enums.length - 1) {
                    check += ' || ';
                    message += ' or ';
                }
            });
            return `assert ${check} : "${key} must be either ${message}",`
        }
        return '';
    }

    const buildTypeAssert = (key, obj, schema) => {
        let type = _.get(obj,'type');

        if (!type){
            const path = _.replace(_.replace(obj['$ref'],'#/',''),'/','.');
            type = _.get(schema,`${path}.type`)
        }

        // jsonschema uses integer while jsonnet uses number
        let stdLibFunction = `std.is${_.upperFirst(type)}`;
        if (type === 'integer') stdLibFunction = `std.isNumber`;

        switch (type) {
            case 'array':
                // no-break
            case 'object':
                // no-break
            case 'boolean':
                // no-break;
            case 'integer':
                // no-break
            case 'string':
                return `assert ${stdLibFunction}(${key}) : '${key} must be a ${type}',`;
            default:
                return `// Type: ${type}`
        }
    }

    const cleanString = (string)=> {
      return _.replace(string,/\n| {2,}|`|Ëš|'/g,'')
    }

    const buildDocumentationForWithFunction = (key, obj, schema) => {
        const cleanDescription = cleanString(_.get(obj,`${key}.description`))
        const jsonnetType = getJsonnetType(key,obj,schema);
        if (_.isEmpty(jsonnetType)){
            return `'#with${key}': d.fn('\`with${key}\` ${key} ${cleanDescription}',[d.arg("${key}")]),`
        }

        return `'#with${key}': d.fn('\`with${key}\` ${key} ${cleanDescription}',[d.arg("${key}",${jsonnetType})]),`
    }

    const getJsonnetType = (key, obj, schema) => {
        let type = _.get(obj,'type');

        if (!type){
            const path = _.replace(_.replace(obj['$ref'],'#/',''),'/','.');
            type = _.get(schema,`${path}.type`)
        }

      switch (type) {
          case 'integer':
              // no-break;
          case 'number':
              return `d.T.integer`;
          case 'object':
              // no-break;
          case 'array':
              // no-break
          case 'boolean':
              // no-break;
          case 'string':
            return `d.T.${type}`;
          default:
            return ``;
      }
    }

    if (!schema) throw new Error('Schema is not set');
    const requiredParameters = _.get(schema,'required');
    const typeName = _.get(schema,'typeName');
    const properties = _.get(schema,'properties');
    const typeParts = _.split(typeName, '::');
    const rootPackage = _.first(typeParts);
    const module = _.nth(typeParts,1);
    const pkg = _.last(typeParts);
-%>
<%- pkg -%>: {
    '#': d.pkg(
        name='<%= pkg %>',
        url='github.com/the-fittest/cloudformation-libsonnet/<%= version %>/<%= rootPackage %>/<%= module %>.libsonnet',
        help='<%= cleanString(_.get(schema,'description')) %>',
        filename=std.thisFile,
    ),
<% if (requiredParameters) { -%>
    '#new': d.fn(
        help=|||
            `new` creates a <%= typeName  %> Resource
    <% _.forEach(requiredParameters,(requiredParameter) => { -%>
        * <%= requiredParameter -%> <%= cleanString(_.get(properties,`${requiredParameter}.description`)) %>
    <%   }); -%>
    |||,
        args=[
    <%   _.forEach(requiredParameters,(requiredParameter) => { -%>
            d.arg("<%= requiredParameter -%>", "<%= getJsonnetType(requiredParameter,properties[requiredParameter],schema) %>"),
    <%   }); -%>
        ]
    ),
    new(
<%   _.forEach(requiredParameters,(requiredParameter) => { -%>
        <%= requiredParameter -%>,
<%   }); -%>
    ): {
<%
} else {
-%>
    '#new': d.fn(
        help=|||
            `new` creates a <%= typeName  %> Resource
    |||,
    ),
    new(): {
<% } -%>
        local base = self,
<% if (requiredParameters) { -%>
        Properties: {
        <%
            _.forEach(requiredParameters, (requiredParameter) => {
        -%>
            <%- buildTypeAssert(requiredParameter,properties[requiredParameter],schema) %>
            <%- buildEnumAssert(requiredParameter,_.get(properties[requiredParameter],'enum')) -%>
            <%= requiredParameter -%>: <%= requiredParameter -%>,
        <% }); -%>
        },
<% } else { -%>
        Properties:: {},
<% } -%>
        DependsOn:: [],
            Type: '<%- typeName -%>',
        },
        dependsOn(DependsOn): {
            DependsOn::: [DependsOn],
        },
<%
    const propertiesKey = _.keys(properties);
    const optionalParameters = _.difference(propertiesKey,requiredParameters);
    _.forEach(optionalParameters, function(optionalParameter) {
-%>
        <%- buildDocumentationForWithFunction(optionalParameter,properties[optionalParameter],schema)%>
        with<%= optionalParameter -%>(<%= optionalParameter -%>): {
            <%- buildTypeAssert(optionalParameter,properties[optionalParameter],schema) %>
            <%- buildEnumAssert(optionalParameter,_.get(properties[optionalParameter],'enum')) -%>
            Properties+::: { <%= optionalParameter -%>: <%= optionalParameter -%> },
        },
<% }); -%>
},
